<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">antoineB's blog: Posts tagged 'racket'</title>
 <link rel="self" href="http://antoineB.github.io/feeds/racket.atom.xml" />
 <link href="http://antoineB.github.io/tags/racket.html" />
 <id>urn:http-antoineB-github-io:-tags-racket-html</id>
 <updated>2017-03-05T13:25:10Z</updated>
 <entry>
  <title type="text">Ideas of a match form for PHP</title>
  <link rel="alternate" href="http://antoineB.github.io/blog/2017/03/05/ideas-of-a-match-form-for-php/?utm_source=racket&amp;utm_medium=Atom" />
  <id>urn:http-antoineB-github-io:-blog-2017-03-05-ideas-of-a-match-form-for-php</id>
  <published>2017-03-05T13:25:10Z</published>
  <updated>2017-03-05T13:25:10Z</updated>
  <author>
   <name>antoine</name></author>
  <content type="html">
&lt;p class="lead"&gt;This post explore the idea of how would look like if pattern matching would be added to PHP.&lt;/p&gt;

&lt;br /&gt;

&lt;p&gt;And by pattern matching i actually mean racket&amp;rsquo;s &lt;a href="https://docs.racket-lang.org/reference/match.html?q=match#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29"&gt;match&lt;/a&gt; form.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="an-example"&gt;An example&lt;/h2&gt;

&lt;div class="brush: php"&gt;
 &lt;pre&gt;&lt;code&gt;&amp;lt;?php

class Maison {
    public $voiture = 1;
    public $camion = 2;
    public function moreVoiture($value) { return $this-&amp;gt;voiture + $value; }
}


match($someExpr) {
    case 12:
        var_dump(12);
        break;
    case "toto": 
        var_dump("toto");
        break;
    case (int) as $someVar:
        var_dump($someVar);
        break;
    case instanceof Maison(-&amp;gt;voiture =&amp;gt; 1, -&amp;gt;camion =&amp;gt; (int) as $r) as $result:
        var_dump($result);
        var_dump($r);
        break;
    case instanceof Maison(-&amp;gt;moreVoiture(2) =&amp;gt; 3, -&amp;gt;camion =&amp;gt; instanceof Maison() as $r) as $result:
        var_dump($result);
        var_dump($r);
        break;
    case [1, 2, (mixed) as $third]:
        var_dump($third);
        break;
    case [...(mixed), (mixed) as $last]: 
        var_dump($last);
        break;
    default:
        break;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Explaining of the behaviors involved here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;12&lt;/code&gt;, &lt;code&gt;&amp;ldquo;toto&amp;rdquo;&lt;/code&gt; or any scalar will be check with  &lt;code&gt;===&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;(int)&lt;/code&gt;, &lt;code&gt;(string)&lt;/code&gt; will match against a type following  PHP rules.&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;(mixed)&lt;/code&gt; is a new rule meaning everything, wildcard. Often written  &lt;code&gt;_&lt;/code&gt; in other pattern matching.&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;instanceof&lt;/code&gt; will check for &lt;code&gt;instanceof&lt;/code&gt; straight  forward. It use &lt;code&gt;-&amp;gt;property&lt;/code&gt; and &lt;code&gt;-&amp;gt;method()&lt;/code&gt; to  make a distinction between properties and methods.&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;&amp;hellip;&lt;/code&gt; is used in array to express 0 or more.&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;as&lt;/code&gt; is used to introduce new variable in the code.&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="the-grammar"&gt;The grammar&lt;/h2&gt;

&lt;p&gt;A kind of yacc grammar, terminals are indicated in quotes and r&amp;rsquo;&amp;rsquo; for regex.&lt;/p&gt;

&lt;div class="brush: yacc"&gt;
 &lt;pre&gt;&lt;code&gt;pattern:
    | scalar as_pattern
    | type as_pattern
    | 'instanceof' classname '(' object_list ')' as_pattern
    | array_pattern as_pattern
    ;

type:
    | '(bool)'
    | '(int)'
    | '(string)'
    | '(resource)'
    | '(float)' 
    | '(array)'
    | '(object)'
    | '(mixed)'
    ;

scalar:
    | r'[0-9]+' // integer
    | r'[0-9]*.[0-9]*' // float
    | r"'[^']*'"
    | r'"[^"]*"' //string
    | true
    | false
    | null
    ;

array_list:
    | pattern ',' array_list
    | pattern
    | '...' pattern ',' array_list
    | '...' pattern
    |
    ;

array_pattern:
    | 'array' '(' array_list ')'
    | '[' array_list ']'
    | 'array' '(' array_key_list ')'
    | '[' array_key_list ']'
    ;

object_list:
    | r'-&amp;gt;[a-zA-Z0-9_]+' '=&amp;gt;' pattern
    | r'-&amp;gt;[a-zA-Z0-9_]+' '(' any_php_expr ')' '=&amp;gt;' pattern
    ;

variable:
    | r'$[a-zA-z0-9_]+' // like $someVar
    ;

as_pattern:
    | // empty
    | 'as' variable
    ;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="implementing-a-poc"&gt;Implementing a P.O.C.&lt;/h2&gt;

&lt;p&gt;Like &lt;code&gt;match&lt;/code&gt;, a macro that spit out racket code, I will implement this as a pre-processor that spit out valid PHP. This is not a usable solution because it breaks line number in errors messages. I have started to write this 
 &lt;abbr title="Proof Of Concept"&gt;POC&lt;/abbr&gt; in the PHP VM (to keep correct line number) but the whole process was slow and cumbersome (&lt;a href="/code/poc_vm.patch"&gt;here is the diff&lt;/a&gt; that pave the basics form commit 85b9055a86 [aka PHP 7.1]). The other problem is that the generated code rely on 3 global variables and the whole thing will turn bad if you mess with them inside a match.&lt;/p&gt;

&lt;p&gt;Some quick glance at how this is done.&lt;/p&gt;

&lt;div class="brush: php"&gt;
 &lt;pre&gt;&lt;code&gt;&amp;lt;?php

match (expr) {
    case pattern: statements... break;
    default: // like switch
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Will ouput:&lt;/p&gt;

&lt;div class="brush: php"&gt;
 &lt;pre&gt;&lt;code&gt;&amp;lt;?php

// If there is a match before every global variables are re-initialized.

// Used to eval expression just once.
$__MATCH__expr = expr;
// Used to store variables and populate (extract) the current scope with them
only if the whole clause match.
$__MATCH__variables = []; // of shape 'variableName' =&amp;gt; value.
$__MATCH__result = true;

// Skeleton of any pattern clause.
$__MATCH__case0 = function ($__MATCH__expr) use (&amp;amp;$__MATCH__variables, &amp;amp;$__MATCH__result) {
    $__MATCH__inner_variables = [];
    $__MATCH__result = true;
    pattern_code;
    if ($__MATCH__result == true) {
        $__MATCH__variables = array_merge($__MATCH__variables, $__MATCH__inner_variables);
    }
    return $__MATCH__result;
}

// Use switch because match has the same behavior of switch regarding break.
switch (true) {
  case $__MATCH__case0($__MATCH__expr):
      extract($__MATCH__variables);
      statements;
      break; // or not
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Another example:&lt;/p&gt;

&lt;div class="brush: php"&gt;
 &lt;pre&gt;&lt;code&gt;&amp;lt;?php

// for case (int) as $someVar: var_dump($someVar); break;

$__MATCH__case2 = function ($__MATCH__expr) use (&amp;amp;$__MATCH__variables, &amp;amp;$__MATCH__result) {
    $__MATCH__inner_variables = [];
    $__MATCH__result = true;
    if ($__MATCH__result === true) {
        if (is_int($__MATCH__expr)) {
            $__MATCH__inner_variables['someVar'] = $__MATCH__expr;
        } else {
            $__MATCH__result = false;
        }
    } 
    if ($__MATCH__result === true) {
        $__MATCH__variables = array_merge($__MATCH__variables, $__MATCH__inner_variables);
    }
    return $__MATCH__result;
}

// and in the switch

// case $__MATCH__case0($__MATCH__expr):
//     extract($__MATCH__variables);
//     var_dump($someVar); break;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I don&amp;rsquo;t go into other examples you get the idea, see &lt;a href="/code/matchphp.rkt"&gt;the preprocessor&lt;/a&gt; or &lt;a href="/code/matchphpexample.php"&gt;an example&lt;/a&gt; and &lt;a href="/code/matchphpexample_output.php"&gt;its output&lt;/a&gt; for more.&lt;/p&gt;

&lt;h2 id="shortcomings"&gt;Shortcomings&lt;/h2&gt;

&lt;p&gt;The above grammar misses several elements from PHP and racket match.&lt;/p&gt;

&lt;h3 id="there-is-no-array-key"&gt;There is no array key&lt;/h3&gt;

&lt;div class="brush: yacc"&gt;
 &lt;pre&gt;&lt;code&gt;string_or_number:
    | r'[0-9]+' // integer
    | r'[0-9]*.[0-9]*' // float
    | r"'[^']*'"
    | r'"[^"]*"' //string
    ;
    
string_or_number_type:
    | '(int)'
    | '(string)'
    | '(mixed)'
    ;

array_list:
    | pattern ',' array_list
    | pattern
    | '...' pattern ',' array_list
    | '...' pattern
    | string_or_number =&amp;gt; pattern ',' array_list
    | string_or_number =&amp;gt; pattern
    | '...' string_or_number_type =&amp;gt; pattern ',' array_list
    | '...' string_or_number_type =&amp;gt; pattern
    |
    ;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="only-scalar-allowed"&gt;Only Scalar allowed&lt;/h3&gt;

&lt;p&gt;If general purpose PHP expression are allowed it is unclear how it will possible to and (&amp;amp;&amp;amp; and also negating !) two clauses without adding a new keyword. The or case is simple it just need to put several case one after the other without break in between.&lt;/p&gt;

&lt;p&gt;I see only 4 solution:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Adding a new keyword like &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Removing expression all together.&lt;/li&gt;
 &lt;li&gt;Removing and not all together.&lt;/li&gt;
 &lt;li&gt;Escape expression with something like &lt;code&gt;eval&lt;/code&gt; example &lt;code&gt;case eval(1 + 1) &amp;amp;&amp;amp; eval($obj-&amp;gt;getStuff()):&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;I will bet on now for removing and not.&lt;/p&gt;

&lt;h3 id="traversable-and-object-behaving-as-array"&gt;Traversable and object behaving as array&lt;/h3&gt;

&lt;p&gt;I would choose still having &lt;code&gt;array&lt;/code&gt; match to check for element be an array. And introduce a new rule like &lt;code&gt;&amp;lsquo;instanceof&amp;rsquo; &amp;lsquo;Traversable&amp;rsquo; &amp;rsquo;(&amp;rsquo; array_list &amp;rsquo;)&amp;rsquo;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="where-are--and-app-from-rackets-match"&gt;Where are &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;app&lt;/code&gt; from racket&amp;rsquo;s match&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;?&lt;/code&gt; it is possible to add a guard:&lt;/p&gt;

&lt;div class="brush: php"&gt;
 &lt;pre&gt;&lt;code&gt;&amp;lt;?php

// case (mixed) as $pattern if (is_something($pattern)):

// $pattern is implicit
// case (mixed) if (is_something($pattern)):

// even (mixed) could be implicit
// case if (is_something($pattern)):&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Go a bit deeper into implicit &lt;code&gt;$pattern&lt;/code&gt;&lt;/p&gt;

&lt;div class="brush: php"&gt;
 &lt;pre&gt;&lt;code&gt;&amp;lt;?php

match ([1]) {
    case [(mixed) if (var_dump($pattern) || true)] if (var_dump($pattern) || true):
}

// will print
// 1
// array(1)

// $pattern is the current part being matched.

// Ifs are executed depth first search.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For the &lt;code&gt;app&lt;/code&gt; parts:&lt;/p&gt;

&lt;div class="brush: php"&gt;
 &lt;pre&gt;&lt;code&gt;// will match [1, 'stuff']
// the next pattern is the return value of evaluated expression.
// case [1, eval(preg*match('/stuff/', $pattern, $m)) =&amp;gt; 1]:

// will match [1, 'stu'] but not [1, 'stuff']
// case [1, eval(preg*match('/stu(ff)?/', $pattern, $m)) use($m) =&amp;gt; [(mixed)]]:
// use($m) substitute $pattern value with $m's value.

// If a callable is given to eval so it is called
// case [1, eval(function ($pattern) { preg_match('/stu(ff)?/', $pattern, $m); return $m; }) =&amp;gt; [(mixed)]]:

// because the syntax with eval could be confusing with a php expression and
// it need to add 'use', another solution is to only allow the function syntax.

// case [1, function ($pattern) { preg_match('/stu(ff)?/', $pattern, $m); return $m; } =&amp;gt; [(mixed)]]:

// verbose but the clearer for me.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="conclusion-with-whole-hypothetical-grammar"&gt;Conclusion with whole hypothetical grammar&lt;/h3&gt;

&lt;p&gt;Regarding previous point here is a grammar that sum it up (contrary to the previous one I didn&amp;rsquo;t check if it didn&amp;rsquo;t run into LLAR conflicts).&lt;/p&gt;

&lt;div class="brush: yacc"&gt;
 &lt;pre&gt;&lt;code&gt;pattern:
    | apply_pattern pattern_without_apply
    | pattern_without_apply
    ;

pattern_without_apply:
    | scalar as_pattern if_pattern
    | type as_pattern if_pattern
    | 'instanceof' 'Traversable' '(' array_list ')' as_pattern if_pattern
    | 'instanceof' classname '(' object_list ')' as_pattern if_pattern
    | array_pattern as_pattern if_pattern
    | php_expr as_pattern if_pattern // hope it doesn't conflict with the rest, array() for exemple
    ;

type:
    | '(bool)'
    | '(int)'
    | '(string)'
    | '(resource)'
    | '(float)' 
    | '(array)'
    | '(object)'
    | '(mixed)'
    ;

scalar:
    | r'[0-9]+' // integer
    | r'[0-9]*.[0-9]*' // float
    | r"'[^']*'"
    | r'"[^"]*"' //string
    | true
    | false
    | null
    ;

array_list:
    | pattern ',' array_list
    | pattern
    | '...' pattern ',' array_list
    | '...' pattern
    |
    ;

array_pattern:
    | 'array' '(' array_list ')'
    | '[' array_list ']'
    | 'array' '(' array_key_list ')'
    | '[' array_key_list ']'
    ;

object_list:
    | r'-&amp;gt;[a-zA-Z0-9_]+' '=&amp;gt;' pattern
    | r'-&amp;gt;[a-zA-Z0-9_]+' '(' any_php_expr ')' '=&amp;gt;' pattern
    ;

variable:
    | r'$[a-zA-z0-9_]+' // like $someVar
    ;

as_pattern:
    | // empty
    | 'as' variable
    ;
    
if_pattern:
    | // empty
    | 'if' '(' php_expr ')'
    ;

apply_pattern:
    | 'function' '(' variable ')' 'use' '(' stuff ')' '{' statements '}' '=&amp;gt;'
    ;

array_key:
    | apply_pattern php_expr as_pattern if_pattern
    | php_expr as_pattern if_pattern
    ;

array_key_ellipsis:
    | '(int)' as_pattern if_pattern 
    | '(string)' as_pattern if_pattern
    | '(mixed)' as_pattern if_pattern
    | apply_pattern pattern_without_apply
    ;

array_list:
    | pattern ',' array_list
    | pattern
    | '...' pattern ',' array_list
    | '...' pattern
    | array_key =&amp;gt; pattern ',' array_list
    | array_key =&amp;gt; pattern
    | '...' array_key_ellipsis =&amp;gt; pattern ',' array_list
    | '...' array_key_ellipsis =&amp;gt; pattern
    |
    ;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It adds most of the feature from racket&amp;rsquo;s &lt;code&gt;match&lt;/code&gt; without adding any new keyword. The missing element are &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;regexp&lt;/code&gt; (very easy to add with a new keyword like &lt;code&gt;&amp;lsquo;preg_match&amp;rsquo; &amp;rsquo;/regex/&amp;rsquo; &amp;rsquo;=&amp;gt;&amp;rsquo; pattern&lt;/code&gt;) and &lt;code&gt;..k&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="the-whole-grammar-if-phpexpr-is-removed-from-allowed-pattern"&gt;The whole grammar if php_expr is removed from allowed pattern&lt;/h4&gt;

&lt;div class="brush: yacc"&gt;
 &lt;pre&gt;&lt;code&gt;pattern:
    | apply_pattern pattern_without_apply
    | pattern_without_apply
    ;

just_pattern:
    | variable
    | scalar 
    | type 
    | 'instanceof' 'Traversable' '(' array_list ')'
    | 'instanceof' classname '(' object_list ')'
    | array_pattern
    ;
    
pattern_without_apply:
    | just_pattern scalar as_pattern if_pattern
    | pattern '&amp;amp;&amp;amp;' pattern
    | pattern '||' pattern 
    | '(' pattern ')' as_pattern if_pattern // resolve ambiguity with as_pattern with '||' and '&amp;amp;&amp;amp;' rule.
    | pattern 'and' just_pattern as_pattern if_pattern
    | pattern 'or' just_pattern as_pattern if_pattern
    | '!' pattern
    ;

type:
    | '(bool)'
    | '(int)'
    | '(string)'
    | '(resource)'
    | '(float)' 
    | '(array)'
    | '(object)'
    | '(mixed)'
    ;

scalar:
    | '==' scalar // weak checking instead of strong one by default
    | r'[0-9]+' // integer
    | r'[0-9]*.[0-9]*' // float
    | r"'[^']*'"
    | r'"[^"]*"' //string
    | true
    | false
    | null
    ;

array_list:
    | pattern ',' array_list
    | pattern
    | '...' pattern ',' array_list
    | '...' pattern
    |
    ;

array_pattern:
    | 'array' '(' array_list ')'
    | '[' array_list ']'
    | 'array' '(' array_key_list ')'
    | '[' array_key_list ']'
    ;

object_list:
    | r'-&amp;gt;[a-zA-Z0-9_]+' '=&amp;gt;' pattern
    | r'-&amp;gt;[a-zA-Z0-9_]+' '(' any_php_expr ')' '=&amp;gt;' pattern
    ;

variable:
    | r'$[a-zA-z0-9_]+' // like $someVar
    ;

as_pattern:
    | // empty
    | 'as' variable
    ;
    
if_pattern:
    | // empty
    | 'if' '(' php_expr ')'
    ;

apply_pattern:
    | 'function' '(' variable ')' 'use' '(' stuff ')' '{' statements '}' '=&amp;gt;'
    ;

array_key:
    | apply_pattern php_expr as_pattern if_pattern
    | php_expr as_pattern if_pattern
    ;

array_key_ellipsis:
    | '(int)' as_pattern if_pattern 
    | '(string)' as_pattern if_pattern
    | '(mixed)' as_pattern if_pattern
    | apply_pattern pattern_without_apply
    ;

array_list:
    | pattern ',' array_list
    | pattern
    | '...' pattern ',' array_list
    | '...' pattern
    | array_key =&amp;gt; pattern ',' array_list
    | array_key =&amp;gt; pattern
    | '...' array_key_ellipsis =&amp;gt; pattern ',' array_list
    | '...' array_key_ellipsis =&amp;gt; pattern
    |
    ;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This one allow weak checking, negating pattern, and of pattern and &lt;code&gt;$var&lt;/code&gt; as a shortcut for &lt;code&gt;(mixed) as $var&lt;/code&gt;.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">exploring typecheking sql query in typed/racket</title>
  <link rel="alternate" href="http://antoineB.github.io/blog/2016/01/09/exploring-typecheking-sql-query-in-typed-racket/?utm_source=racket&amp;utm_medium=Atom" />
  <id>urn:http-antoineB-github-io:-blog-2016-01-09-exploring-typecheking-sql-query-in-typed-racket</id>
  <published>2016-01-09T17:48:19Z</published>
  <updated>2016-01-09T17:48:19Z</updated>
  <author>
   <name>antoine</name></author>
  <content type="html">
&lt;p class="lead"&gt;This post will describe a 
 &lt;abbr title="Proof Of Concept"&gt;POC&lt;/abbr&gt; on how to typecheck sql query in typed/racket.&lt;/p&gt;

&lt;br /&gt;

&lt;p&gt;The goal is to make this typecheck:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(: some-query : (Listof (Vector String String)))
(define some-query
  (query
   movies
   #:from     ([actor a] [movie m])
   #:where    (= a.name "Jhon Wayne")
   #:select   (a.name m.name)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With the schema defined as:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(define-schema movies
  (actor    [id Integer]
            [name String])
  (movie    [id Integer]
            [name String]
            [director_id Integer])
  (director [id Integer]
            [name String]))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- more--&gt;

&lt;p&gt;This 
 &lt;abbr title="Proof Of Concept"&gt;POC&lt;/abbr&gt; already take me too much time so there will be shortcomings the full source code is available &lt;a href="/code/typed-db.rkt"&gt;here&lt;/a&gt; and its &lt;a href="/code/typed-db-example.rkt"&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="the-define-schema-macro"&gt;The define-schema macro&lt;/h2&gt;

&lt;p&gt;This macro will define a syntax transformer retaining the schema information to be used later by the &lt;code&gt;query&lt;/code&gt; macro. The type of the columns didn&amp;rsquo;t reflect any SQL type it is just typed/racket types, user defined types could be used also.&lt;/p&gt;

&lt;p&gt;The code isn&amp;rsquo;t worth commenting the expanded code will be:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(define-syntax movies
  (schema-st 
   (list 
    'movies
    (quote-syntax
     ((actor ((id Integer) (name String)))
      (movie ((id Integer) (name String) (director_id Integer)))
      (director ((id Integer) (name String))))))))
      
(define-for-syntax (struct schema-st (data) #:property prop:procedure (lambda (st) (schema-st-data st))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is completely straight forward it defines a &lt;code&gt;movie&lt;/code&gt; transformer that retains data available for other macros.&lt;/p&gt;

&lt;p&gt;For shortcoming reasons it&amp;rsquo;s unclear if using the struct schema is necessary or if &lt;code&gt;(define-syntax movies (list &amp;hellip;))&lt;/code&gt; would have done the trick.&lt;/p&gt;

&lt;p&gt;Also, the data structure shouldn&amp;rsquo;t have been a complete syntax object of the whole schema information but just a syntax object of the types, like:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;`(movies
  ((actor ((id ,#'Integer) (name ,#'String)))
   (movie ((id ,#'Integer) (name ,#'String) (director_id ,#'Integer)))
   (director ((id ,#',#'Integer) (name ,#'String)))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And it also could output type alias to have abstract type:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(define-type movies.actor.id Integer)
(define-type movies.actor.name String)
(define-type movies.movie.id Integer)
;;...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="the-query-macro"&gt;The query macro&lt;/h2&gt;

&lt;p&gt;Copied the example here to refresh your mind.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(: some-query : (Listof (Vector String String)))
(define some-query
  (query
   movies
   #:from     ([actor a] [movie m])
   #:where    (= a.name "Jhon Wayne")
   #:select   (a.name m.name)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This one take the definition by whatever you have named it, &lt;code&gt;movies&lt;/code&gt; in this case. It will fetch the schema definition thought &lt;code&gt;syntax-local-value&lt;/code&gt; so you have to pass the &lt;code&gt;movies&lt;/code&gt; every time you use the &lt;code&gt;query&lt;/code&gt; macro.&lt;/p&gt;

&lt;p&gt;As you would expect this macro check that &lt;code&gt;#:from&lt;/code&gt; and &lt;code&gt;#:select&lt;/code&gt; are present only once, bark if an alias isn&amp;rsquo;t defined for each table, for select and where it checks the columns &lt;code&gt;name&lt;/code&gt; are present in table &lt;code&gt;actor&lt;/code&gt; and &lt;code&gt;movie&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The expanded code isn&amp;rsquo;t even useful just to ensure the typecheking mechanism works.&lt;/p&gt;

&lt;p&gt;The two interesting parts are:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;It uses &lt;code&gt;ann&lt;/code&gt; on the where expression to ensure it has the type of  &lt;code&gt;a.name&lt;/code&gt; so it gives &lt;code&gt;(ann &amp;ldquo;Jhon Wayne&amp;rdquo; String)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;It uses &lt;code&gt;cast&lt;/code&gt; on the query result and generate runtime assertion on  every rows. Typed/racket didn&amp;rsquo;t provide an &lt;code&gt;unsafe-cast&lt;/code&gt; form yet.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The expansion could look like:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(: some-query : (Listof (Vector String String)))
(define some-query
  (cast (exec-query 
         "SELECT a.name, m.name FROM actor AS a, movie AS m WHERE a.name = ?"
         (ann "Jhon Wayne" String))
        (Listof (Vectorof String String))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;Using &lt;code&gt;cast&lt;/code&gt; could be costly maybe generate our own guard with  predicate could reduce this cost.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Have to pass the schema definition to every &lt;code&gt;query&lt;/code&gt; could be  tedious and inelegant. Maybe &lt;code&gt;racket/stxparam&lt;/code&gt; could help or maybe  &lt;code&gt;define-schema&lt;/code&gt; should generate a transformer  &lt;code&gt;query-movies&lt;/code&gt; that is like &lt;code&gt;query&lt;/code&gt; without the  &lt;code&gt;movie&lt;/code&gt; part.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The &lt;code&gt;query&lt;/code&gt; 
   &lt;abbr title="Domain Specific Language"&gt;DSL&lt;/abbr&gt; is  redundant with SQL because it&amp;rsquo;s already a DSL. It may be possible to use a  reader for SQL something like &lt;code&gt;#sql"SELECT * FROM table"&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The types of the schema information didn&amp;rsquo;t reflect the SQL type, the ability  to pass any kind of type alone isn&amp;rsquo;t useful, it should also pass two  procedures one to convert from the complex type to some SQL representation  and the inverse. Example: if you want to use json in some column  &lt;code&gt;option&lt;/code&gt; of type &lt;code&gt;TEXT&lt;/code&gt; the definition should be  &lt;code&gt;[options Json read-json write-json]&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All this is an awful lot of works. :)&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</content></entry>
 <entry>
  <title type="text">Mapping data from sql result to struct</title>
  <link rel="alternate" href="http://antoineB.github.io/blog/2015/07/06/mapping-data-from-sql-result-to-struct/?utm_source=racket&amp;utm_medium=Atom" />
  <id>urn:http-antoineB-github-io:-blog-2015-07-06-mapping-data-from-sql-result-to-struct</id>
  <published>2015-07-06T17:15:05Z</published>
  <updated>2015-07-06T17:15:05Z</updated>
  <author>
   <name>antoine</name></author>
  <content type="html">
&lt;p class="lead"&gt;This post describe the implementation of a descriptive macro to fill structures from sql result.&lt;/p&gt;

&lt;br /&gt;

&lt;h2 id="the-goal"&gt;The goal&lt;/h2&gt;

&lt;p&gt;At end of this post we will archive this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;;; assume the table actor exist and have at least id, name, age

(struct actor ([id #:auto] [name #:auto] [age #:auto]) 
  #:transparent #:mutable #:auto-value #f)

(select
    (["id" actor id]
     ["name" actor name]
     ["age" actor age])
  "SELECT a.* FROM actor AS a where a.id = $1"
  12)
;; =&amp;gt; '(((actor 12 "some name" 80)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- more--&gt;

&lt;p&gt;It easily creates struct out of sql result.&lt;/p&gt;

&lt;h2 id="implementation"&gt;Implementation&lt;/h2&gt;

&lt;p&gt;First the mapping function, for every row create the defined struct, and apply the setter according to column name.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(require db)

;; a parameter to not have to pass around the database connection.
(define current-database-connection (make-parameter #f))

(define (select-fn mapping request . args)
  ;; Return the list in order of the select column name
  (define (header-&amp;gt;name header)
    (map (lambda (x) (cdr (assoc 'name x))) header))
  ;; Run the sql query get the data and the header
  (match-define (struct rows-result ((app header-&amp;gt;name headers) data))
    (apply query (list* (current-database-connection) request args)))
  ;; Build the struct and make their instances available from their constructor
  ;; procedure
  (define (build-structs)
    (for/hash ([constructor (in-set (list-&amp;gt;set (map third mapping)))])
      (values constructor (constructor))))
  ;; A structure that map every index to the setter and constructor procedure
  (define to-mappeds (let loop ([names (for/hash ([mapped mapping])
                                         (values (first mapped) (rest mapped)))]
                                [indice 0]
                                [headers headers]
                                [result #hash()])
                       (if (or (empty? headers) (hash-empty? names))
                           result
                           (let* ([header (first headers)]
                                  [present (hash-ref names header #f)])
                             (loop
                              (if present (hash-remove names header) names)
                              (add1 indice)
                              (rest headers)
                              (if present (hash-set result indice
                                                    (hash-ref names header))
                                  result))))))
  (define length-row (length headers))
  (for/list ([row data])
    ;; build a new set of structure for each row
    (define structs (build-structs))
    ;; for each column fetch the relevant struct instance and apply its setter
    (for ([(name to-mapped) to-mappeds])
      ((first to-mapped)
       (hash-ref structs (second to-mapped))
       (vector-ref row name)))
    (hash-values structs)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;;; and an example to make the thing clearer
(select-fn (list
             (list "id" set-actor-id! actor)
             (list  "name" set-actor-name! actor)
             (list "age" set-actor-age! actor)
             (list "gender" set-actor-gender! actor))
           "SELECT a.* FROM actor AS a")&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Second the syntax transformer, the bare minimal to output the example above:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(begin-for-syntax
  (require syntax/parse
           racket/string))

(define-syntax (select stx)
  (syntax-parse stx
    [(_ stmt:str args ...)
     #`(query (current-database-connection) stmt #,@#'(args ...))]
    [(_ (attributes ...) stmt:str args ...)
     #`(select-fn
        (list
         #,@(map
             (lambda (x)
               (let* ([lst (syntax-&amp;gt;list x)]
                      [setter (string-append "set-" 
                                             (symbol-&amp;gt;string (syntax-e (cadr lst)))
                                             "-" 
                                             (symbol-&amp;gt;string (syntax-e (caddr lst)))
                                             "!")])
                 (list #'list (car lst) (datum-&amp;gt;syntax x (string-&amp;gt;symbol setter)) (cadr lst))))
             (syntax-&amp;gt;list #'(attributes ...))))
        stmt
        #,@#'(args ...))]))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="shortcoming-and-evolution"&gt;Shortcoming and evolution&lt;/h2&gt;

&lt;p&gt;The first shortcoming is the relying on mutable and empty constructor fields, using the struct-info it should be possible to make the link between the field name and the position but probably can&amp;rsquo;t specify a non-empty constructor will not be missing arguments at runtime.&lt;/p&gt;

&lt;p&gt;Its is not possible to use multiple time the same struct definition:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(select
    (["id" actor id]
     ["name" actor name]
     ["age" actor age]
     ["b_id" actor id]
     ["b_name" actor name]
     ["b_age" actor age])
  "SELECT a.*, b.id as b_id, b.name as b_name, b.age as b_age FROM actor AS a FROM actor AS b")&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The two actor will be conflicting, we need to specify which one we want to be filled with, for example like:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(select
  ((actor "mister a"
     ["id" id]
     ["name" name]
     ["age" age])
   (actor "mister b"
     ["b_id" id]
     ["b_name" name]
     ["b_age" age]))
  "SELECT a.*, b.id as b_id, b.name as b_name, b.age as b_age FROM actor AS a FROM actor AS b")&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As shown with the example above the column with same name is problematic, its need to be explicitly changed &amp;ldquo;b.id AS b_id&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Extract knowledge from the SQL string and apply some checks, and go even further with an awareness of the schema.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">basic fastcgi with racket</title>
  <link rel="alternate" href="http://antoineB.github.io/blog/2015/06/02/basic-fastcgi-with-racket/?utm_source=racket&amp;utm_medium=Atom" />
  <id>urn:http-antoineB-github-io:-blog-2015-06-02-basic-fastcgi-with-racket</id>
  <published>2015-06-02T17:06:53Z</published>
  <updated>2015-06-02T17:06:53Z</updated>
  <author>
   <name>antoine</name></author>
  <content type="html">
&lt;p class="lead"&gt;The objective is to implement the most basic working fastcgi protocol in pure racket.&lt;/p&gt;

&lt;br /&gt;

&lt;h2 id="how-it-works"&gt;How it works&lt;/h2&gt;

&lt;p&gt;The minimal &lt;a href="fastcgi.com/devkit/doc/fcgi-spec.html"&gt;fastcgi implementation&lt;/a&gt; will look like:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;wait on a tcp connection&lt;/li&gt;
 &lt;li&gt;read all input data&lt;/li&gt;
 &lt;li&gt;write output hello world like data&lt;/li&gt;
 &lt;li&gt;close connection&lt;/li&gt;&lt;/ol&gt;
&lt;!-- more--&gt;

&lt;p&gt;A request is composed of parts denoted here as &lt;em&gt;segment&lt;/em&gt;. Each segment is composed of a header of 8 bytes and some data of 
 &lt;var&gt;N&lt;/var&gt; bytes and padding of 
 &lt;var&gt;M&lt;/var&gt; bytes where 
 &lt;var&gt;N&lt;/var&gt; and 
 &lt;var&gt;M&lt;/var&gt; &amp;gt;=0.&lt;/p&gt;

&lt;p&gt;The header is:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;fastcgi version (don&amp;rsquo;t care)&lt;/li&gt;
 &lt;li&gt;segment type (init request, end request, stdin, data, stdout, strerr etc&amp;hellip;)&lt;/li&gt;
 &lt;li&gt;request id&lt;/li&gt;
 &lt;li&gt;request id (don&amp;rsquo;t care, it is useful when the connection is shared for multiple request, not the case here)&lt;/li&gt;
 &lt;li&gt;data length&lt;/li&gt;
 &lt;li&gt;data length&lt;/li&gt;
 &lt;li&gt;padding length&lt;/li&gt;
 &lt;li&gt;void&lt;/li&gt;&lt;/ol&gt;

&lt;h2 id="racket-implementation"&gt;Racket implementation&lt;/h2&gt;

&lt;p&gt;The decoding incoming bytes part:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;#lang racket

;; to store the input data
(struct request [segment-id stdin data params] #:mutable #:transparent)

(define (create-empty-request)
  (request #f (open-output-bytes) (open-output-bytes) (open-output-bytes)))

(define (decode-segment request in out)
  ;; don't care if read-bytes return eof
  (define header (read-bytes 8 in))
  (define segment-type (bytes-ref header 1))
  (define segment-id (+ (arithmetic-shift (bytes-ref header 2) 8)
                          (bytes-ref header 3)))
  ;; don't care if read-bytes return eof
  (define data-length (+ (arithmetic-shift (bytes-ref header 4) 8)
                         (bytes-ref header 5)))
  (define data (read-bytes data-length in))
  ;; consume the padding bytes
  (void (read-bytes (bytes-ref header 6) in))

  (printf "segment type: ~a\n" segment-type)
  (printf "id: ~a\n" segment-id)
  (printf "data length: ~a\n" data-length)
  (printf "~a\n" data)

  ;; segment-id = 0 is a special case where the web server and the fastcgi
  ;; process exchange information like n° of maximum connection so... we don't
  ;; care.
  (when (= 0 segment-id)
    (raise "unimplemented"))

  (printf "~a\n" request)

  (case segment-type
    ;; fcgi beginrequest
    ((1) (set-request-segment-id! request segment-id))
    ;; fcgi params
    ((4) (display data (request-params request)))
    ;; fcgi stdin
    ((5) (if (= 0 data-length) ; Not sure if it's the rigth way but use that to
                               ; know if the webserver input is over.
             (respond request out)
             (display data (request-stdin request))))
    ;; fcgi data
    ((8) (display data (request-data request)))
    ;; fcgi get values
    ;; fcgi abort request
    ((2 9) (raise "unimplemented"))
    (else (raise "undocumented type"))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The response:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(define (build-header type id data-length padding-length)
  (bytes 1 type
         (arithmetic-shift id -8) (modulo id 256)
         (arithmetic-shift data-length -8) (modulo data-length 256)
         padding-length 0))

(define (respond request out)
  ;; header of the stdout
  (write-bytes (build-header 6 (request-segment-id request) 64 0) out)
  ;; the stdout data
  (write-bytes
   #"Content-type: text/html\r\n\r\n&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;hello fcgi&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; "
   out)
  ;; an empty stdout data to indicate we have finish the stdout stream
  (write-bytes (build-header 6 (request-segment-id request) 0 0) out)
  ;; the end request type
  (write-bytes (build-header 3 (request-segment-id request) 8 0) out)
  (write-bytes (bytes 0 0 0 0 0 0 0 0) out)
  (close-output-port out))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The server:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(module+ main
  (require racket/tcp)
  (define server (tcp-listen 1025))
  (let loop-main ()
    (let-values ([(in out) (tcp-accept server)]
                 [(request) (create-empty-request)])
      (let loop ()
        (if (port-closed? out)
            ;; the end of the request
            (close-input-port in)
             (begin
               (decode-segment request in out)
               (loop))))
      )
    (loop-main)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Nginx configuration:&lt;/p&gt;

&lt;div class="brush: nginx"&gt;
 &lt;pre&gt;&lt;code&gt;location ~ \.rkt$ {
    fastcgi_pass 127.0.0.1:1025;
    include fastcgi.conf; # this add several parameters to be pass
                          # to the fastcgi process like http method.
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;go to &lt;em&gt;http://localhost/anything.rkt&lt;/em&gt; that display &amp;ldquo;hello fcgi&amp;rdquo;&lt;/p&gt;

&lt;h2 id="display-the-http-headers"&gt;Display the HTTP headers&lt;/h2&gt;

&lt;p&gt;First of all we need to extract the parameters form the request-params field, it is &lt;a href="http://www.fastcgi.com/devkit/doc/fcgi-spec.html#S3.4"&gt;name, value pair&lt;/a&gt; with their respective length before.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(define (decode-params in)
  (define (decode-param-length in)
    (define b3 (read-byte in))
    (cond [(equal? b3 eof) eof]
          [(&amp;gt; b3 #x7f)
           (let ([others (read-bytes 3 in)])
             (+
              (arithmetic-shift (bitwise-and b3 #x7f) 24)
              (arithmetic-shift (bytes-ref others 2) 16)
              (arithmetic-shift (bytes-ref others 1) 8)
              (bytes-ref others 0)))]
          [else b3]))
  (let loop ([result empty])
    (let ([length0 (decode-param-length in)])
      (if (equal? eof length0)
          result
          (let ([length1 (decode-param-length in)])
            (loop
             (cons
              (cons (read-bytes length0 in)
                    (read-bytes length1 in))
              result)))))))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Apply this decoder and present them, also do convenience functions.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(define (fcgi-end-request id out)
  (write-bytes (build-header 3 id 8 0) out)
  (write-bytes (bytes 0 0 0 0 0 0 0 0) out)
  (close-output-port out))
 
(define (write-fcgi-stdout id data out [close #f])
  (define data-length (bytes-length data))
  (define padding-length (if (= 0 (modulo data-length 8)) 0 (- 8 (modulo data-length 8))))
  (write-bytes (build-header 6 id data-length padding-length) out)
  (write-bytes data out)
  (when (not (= 0 padding-length))
    (write-bytes (make-bytes padding-length) out))
  (when close
    (write-bytes (build-header 6 id 0 0) out)))

(define (respond request out)
  ;; get the data from request
  (define params (decode-params
                  (open-input-bytes (let ([port (request-params request)])
                                      (close-output-port port)
                                      (get-output-bytes port)))))
  (define data (open-output-bytes))
  (write-bytes #"Content-type: text/html\r\n\r\n&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;" data)
  (write-bytes #"&amp;lt;table&amp;gt;" data)
  (for ([param params])
    (write-bytes #"&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;" data)
    (write-bytes (car param) data)
    (write-bytes #"&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;" data)
    (write-bytes (cdr param) data)
    (write-bytes #"&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;" data))
  (write-bytes #"&amp;lt;/table&amp;gt;" data)
  (write-bytes #"&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;" data)
  (close-output-port data)

  (write-fcgi-stdout (request-segment-id request)
                     (get-output-bytes data)
                     out
                     #t)
  ;; the end request type
  (fcgi-end-request (request-segment-id request) out))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="performance-expectation"&gt;Performance expectation&lt;/h2&gt;

&lt;p&gt;To have an idea where the n° of requests per seconds I used &lt;code&gt;ab -c 25 -n 10000&lt;/code&gt; on several configurations:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;racket web/server (a web server written in pure racket): 1300&lt;/li&gt;
 &lt;li&gt;nginx + chicken fastcgi binding: 10000&lt;/li&gt;
 &lt;li&gt;nginx + php fpm (5 worker thread seems to be the optimal on my 2 core cpu): 7700&lt;/li&gt;
 &lt;li&gt;nginx: 18000&lt;/li&gt;
 &lt;li&gt;my stuff: 300&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Wait what 300, something is wrong obviously, furthermore &lt;code&gt;ab&lt;/code&gt; get stuck most of the time at the last 1000 request. After suspecting the gc I find that I didn&amp;rsquo;t read the doc for &lt;a href="http://docs.racket-lang.org/reference/tcp.html?q=tcp-liste#%28def._%28%28lib._racket%2Ftcp..rkt%29._tcp-listen%29%29"&gt;tcp-listen&lt;/a&gt; and changed the max-allow-wait to something like 1024. And get then 2500 request/second, even more by removing printf to 6500 r/s.&lt;/p&gt;

&lt;p&gt;&lt;a href="/code/fastcgi.rkt"&gt;The whole code&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="adding-threads"&gt;Adding threads&lt;/h2&gt;

&lt;p&gt;The server can still handle one request at a time waiting for the first to finish. Using the green thread of racket will enable to execute request concurrently.&lt;/p&gt;

&lt;p&gt;The change to the code is straightforward just create a new thread for &lt;strong&gt;every&lt;/strong&gt; incoming request.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(module+ main
  (require racket/tcp)
  (define server (tcp-listen 1025 1024 #t))
  (let loop-main ()
    (let-values ([(in out) (tcp-accept server)]
                 [(request) (create-empty-request)])
      (thread
       (lambda ()
         (let loop ()
           ;; similate work
           (sleep sleeping-time)
           (if (port-closed? out)
               ;; the end of the request
               (close-input-port in)
               (begin
                 (decode-segment request in out)
                 (loop))))
         ))
      )
    (loop-main)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;To show the difference from before lets simulate some work with the sleeping-time variable and use &lt;code&gt;ab -c 100 -n 10000&lt;/code&gt; to run our experiments.&lt;/p&gt;

&lt;p&gt;From the previous &lt;strong&gt;non&lt;/strong&gt; threaded code:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;var&gt;sleeping-time&lt;/var&gt;=0.0001 -&amp;gt; 1600 request/s&lt;/li&gt;
 &lt;li&gt;
  &lt;var&gt;sleeping-time&lt;/var&gt;=0.001 -&amp;gt; 196 request/s&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;With threaded code:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;var&gt;sleeping-time&lt;/var&gt;=0.01 -&amp;gt; 1900 request/s&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Even for heavier work the threaded code is faster.&lt;/p&gt;

&lt;h3 id="a-round-robin-strategy"&gt;A round robin strategy&lt;/h3&gt;

&lt;p&gt;Instead of create a new thread and a new request every time we have an incoming request, create a bunch of thread and select them through a round robin approach.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(module+ main
  (require racket/tcp)
  (define server (tcp-listen 1025 1024 #t))

  (define max-thread 100)
  (define round-robin
    (let ([robin 0])
      (lambda ()
        (define rob (modulo (add1 robin) max-thread))
        (set! robin rob)
        rob)))


  (define (create-thread request)
  (define (reset-request! request)
    (set-request-segment-id! request #f)
    (set-request-stdin! request (open-output-bytes))
    (set-request-data! request (open-output-bytes))
    (set-request-params! request (open-output-bytes)))

  (thread
     (lambda ()
       (let main-loop ()
         (define in (thread-receive))
         (define out (thread-receive))
         (reset-request! request)
         (let loop ()
           (sleep 0.0001)
           (if (port-closed? out)
               ;; the end of the request
               (close-input-port in)
               (begin
                 (decode-segment request in out)
                 (loop))))
         (main-loop)))))

  (define thread-vec (for/vector ([i (range max-thread)])
                       (create-thread (create-empty-request))))

  (let loop-main ()
    (let-values ([(in out) (tcp-accept server)]
                 #;[(request) (create-empty-request)]
                 [(rob) (round-robin)])

      (thread-send (vector-ref thread-vec rob) in)
      (thread-send (vector-ref thread-vec rob) out)
      )
    (loop-main)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I have no idea which approach is better, if I increase the number of concurrent connection in apache bench the round robin seems to do better, but this is maybe just due to the fact that round robin set a fixed maximum number of threads.&lt;/p&gt;

&lt;p&gt;&lt;a href="/code/fastcgi-robin.rkt"&gt;round robin code&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="gambit-implementation"&gt;Gambit implementation&lt;/h2&gt;

&lt;p&gt;Quickly do a gambit implementation and get 6800 request/second.&lt;/p&gt;

&lt;p&gt;&lt;a href="/code/fastcgi-gambit.scm"&gt;gambit code&lt;/a&gt;&lt;/p&gt;</content></entry></feed>